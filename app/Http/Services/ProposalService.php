<?php

namespace App\Http\Services;

use App\Exceptions\NotFoundException;
use App\Http\Repositories\ProposalRepository;
use App\Http\Resource\ProposalResource;
use App\Http\Services\Publish\PublishTokenStrategy\PublishTokenServiceFactory;
use App\Models\Proposal;
use App\Models\PublishDetail;
use App\Models\User;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Foundation\Auth\User as Authenticatable;

class ProposalService extends BaseService
{
    public function __construct(
        ProposalRepository $proposalRepository,
    ) {
        $this->repository = $proposalRepository;
    }

    public function resource(): string
    {
        return ProposalResource::class;
    }

    protected function beforeStore(array $data, Authenticatable|User $user): array
    {
        $data['created_by'] = $user->getKey();
        $data['status'] = Proposal::PROPOSAL_STATUS_CREATED;

        return $data;
    }

    /**
     * @param Model $model
     * @param array $data
     * @param User|Authenticatable $user
     * @return void
     * @throws NotFoundException
     */
    protected function afterStore(Model $model, array $data, User|Authenticatable $user): void
    {
        /** @var Proposal $model */
        $sortOrder = 0;
        $data['estimates'] = array_reverse($data['estimates']);
        foreach ($data['estimates'] as $estimateId) {
            $model->estimates()->attach($estimateId, ['created_at' => now(), 'sort_order' => $sortOrder]);
            $sortOrder++;
        }
        $params['entity_type'] = PublishDetail::ENTITY_TYPE_PROPOSAL;
        $params['entity_id'] = $model->getKey();
        PublishTokenServiceFactory::getService(PublishDetail::ENTITY_TYPE_PROPOSAL)->createToken($params, $user);


        parent::afterStore($model, $data, $user); // TODO: Change the autogenerated stub
    }

    protected function beforeUpdate(array $data, Model $model, Authenticatable|User $user): array
    {
        $data['updated_by'] = $user->getKey();
        /** @var Proposal $model */
        $model->estimates()->detach();

        return $data;
    }

    protected function afterUpdate(Model $model, array $data, Authenticatable|User $user): void
    {
        /** @var Proposal $model */
        $sortOrder = 0;
        $data['estimates'] = array_reverse($data['estimates']);
        foreach ($data['estimates'] as $estimateId) {
            $model->estimates()->attach($estimateId, ['created_at' => now(), 'sort_order' => $sortOrder]);
            $sortOrder++;
        }
    }

    /**
     * @param array $params
     * @return Model|null
     * @throws NotFoundException
     */
    public function getPublicProposalData(array $params): ?Model
    {
        /** @var PublishDetail $token */
        $token = PublishTokenServiceFactory::getService(PublishDetail::ENTITY_TYPE_PROPOSAL)->getTokenDetails(
            $params['token'],
        );

        return $this->repository->findById($token->entity_id, relation: [
            'estimates',
            'estimates.customFields',
            'estimates.customFields.customField',
            'estimates.opportunity.customFields',
            'estimates.opportunity.customFields.customField',
            'estimates.account.customFields',
            'estimates.account.customFields.customField',
            'estimates.contact.customFields',
            'estimates.contact.customFields.customField',
        ]);
    }

    public function getPublicStats(?Proposal $proposal)
    {
        if (empty($proposal)) {
            return [];
        }

        $publishDetails = PublishDetail::query()->where('entity_type', PublishDetail::ENTITY_TYPE_PROPOSAL)
            ->where('entity_id', $proposal->getKey())->first();

        if (!$publishDetails) {
            return [];
        }

        return $publishDetails->logs;
    }

    public function getAll(array $params, Authenticatable|User $user): array
    {
        if (isset($params['accountId']) && !empty($params['accountId'])) {
            return $this->paginate(
                $this->repository->getForAccountId($params),
            );
        }


        return $this->paginate(
            $this->repository->get($user, $params),
        );
    }
}
